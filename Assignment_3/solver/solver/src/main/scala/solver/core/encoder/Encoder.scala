package solver.core.encoder

import solver.core.SatSolver
import solver.expressions.BooleanVar
import solver.expressions.IntVar
import solver.core.Assignment
import solver.core.CSP
import solver.expressions.Literal

abstract class Encoder(csp: CSP, val satSolver: SatSolver) {
  /** Returns true when the CSP is not encoded */
  var firstTime = true
  /** Remembers the number of SAT variables used */
  var satVariableCount = 0
  /** Remembers the number of SAT clauses used */
  var satClauseCount = 0
  /** Remembers the code of each integer variable in CSP */
  var varCodeMap: Map[IntVar, Int] = Map.empty
  /** Remembers the code of each Boolean variable in CSP */
  var boolCodeMap: Map[BooleanVar, Int] = Map.empty
  /**
   * Represents the integer constant for true literal (Integer.MAX_VALUE).
   * It is only used during the encoding process, and does not appear in the generated clause finally.
   */
  val TrueLit = Integer.MAX_VALUE
  /**
   * Represents the integer constant for false literal (-Integer.MAX_VALUE).
   * It is only used during the encoding process, and does not appear in the generated clause finally.
   */
  val FalseLit = -TrueLit

  var variablesSizeEncoded = 0
  var boolsSizeEncoded = 0
  var constraintsSizeEncoded = 0

  /** Resets the encoder. */
  def reset {
    satSolver.reset
    firstTime = true
    satVariableCount = 0
    satClauseCount = 0
    varCodeMap = Map.empty
    boolCodeMap = Map.empty
    // added by Soh
    variablesSizeEncoded = 0
    boolsSizeEncoded = 0
    constraintsSizeEncoded = 0
  }

  def addClause(clause: Seq[Int]) {
    val clause1 = clause.filter(_ != FalseLit)
    if (clause1.contains(TrueLit)) {
    } else if (clause1.isEmpty) {
      satSolver.addClause(Seq(1))
      satSolver.addClause(Seq(-1))
      satClauseCount += 2
    } else {
      satSolver.addClause(clause1)
      satClauseCount += 1
    }
  }

  /** Adds all clauses by calling `addClause` method of this class. */
  def addAllClauses(clauses: Seq[Seq[Int]]) {
    for (clause <- clauses if !clause.contains(TrueLit))
      addClause(clause)
  }

  /** Creates a new Boolean variable, adds it to the CSP, and registers it to `boolCodeMap`. */
  def newBool = {
    val p = csp.newBool
    boolCodeMap += p -> (satVariableCount + 1)
    satVariableCount += 1
    p
  }

  /** Returns the lower bound value of `x`. */
  def lb(x: IntVar): Int = x.min
  /** Returns the upper bound value of `x`. */
  def ub(x: IntVar): Int = x.max
  /** Returns the lower bound value of `a*x`. */
  def lb(a: Int, x: IntVar): Int = if (a > 0) a * lb(x) else a * ub(x)
  /** Returns the upper bound value of `a*x`. */
  def ub(a: Int, x: IntVar): Int = if (a > 0) a * ub(x) else a * lb(x)
  /** Returns the lower bound value of the linear summation. */
  def lb(axs: Seq[(Int, IntVar)]): Int = axs.map { case (a, x) => lb(a, x) }.sum
  /** Returns the upper bound value of the linear summation. */
  def ub(axs: Seq[(Int, IntVar)]): Int = axs.map { case (a, x) => ub(a, x) }.sum

  /**
   * Returns the value of `floor(b / a)`.
   * This is used because math.floor is slow.
   */
  def floorDiv(b: Int, a: Int) =
    if (a > 0) {
      if (b >= 0) b / a else (b - a + 1) / a
    } else {
      if (b >= 0) (b - a - 1) / a else b / a
    }

  /**
   * Returns the value of `ceil(b / a)`.
   * This is used because math.ceil is slow.
   */
  def ceilDiv(b: Int, a: Int) =
    if (a > 0) {
      if (b >= 0) (b + a - 1) / a else b / a
    } else {
      if (b >= 0) b / a else (b + a + 1) / a
    }

  /** Returns the number of SAT variables required to encode `x`. */
  def satVariablesSize(x: IntVar): Int

  /** Returns the code of `x`. */
  def code(x: IntVar) = varCodeMap(x)

  /** Returns the code of `p`. */
  def code(p: BooleanVar) = boolCodeMap(p)

  /** Returns the list of clauses generated by encoding integer variable `x`. */
  def encode(x: IntVar): Seq[Seq[Int]]

  /**
   * Returns the list of clauses generated by encoding literal `lit`.
   * `clause0` should be added to each clause generated.
   */
  def encode(lit: Literal, clause0: Seq[Int]): Seq[Seq[Int]]

  /** Returns the list of clauses generated by encoding clausal form constraint `c`. */
  def encode(c: Seq[Literal]): Seq[Seq[Int]] =
    if (c.isEmpty) Seq(Seq.empty)
    else {
      for {
        clause0 <- encode(c.tail)
        clause <- encode(c.head, clause0)
      } yield clause
    }

  /** Adds the constraint to CSP after preprocessing and encodes it. */
  def add(c: Literal): Unit

  /** Encodes the whole CSP when `firstTime` is true.  Otherwise, does nothing. */
  def encodeCSP {
    if (csp.rollbackHappen) {
      // rollback
      satSolver.reset
      variablesSizeEncoded = 0
      boolsSizeEncoded = 0
      constraintsSizeEncoded = 0
      csp.rollbackHappen = false
    }

    for (n <- variablesSizeEncoded to csp.variables.size - 1) {
      varCodeMap += csp.variables(n) -> (satVariableCount + 1)
      satVariableCount += satVariablesSize(csp.variables(n))
    }
    for (n <- boolsSizeEncoded to csp.bools.size - 1) {
      boolCodeMap += csp.bools(n) -> (satVariableCount + 1)
      satVariableCount += 1
    }
    for (n <- variablesSizeEncoded to csp.variables.size - 1)
      addAllClauses(encode(csp.variables(n)))

    val oldConstraints = csp.constraints
    csp.constraints = csp.constraints.take(constraintsSizeEncoded)
    for (n <- constraintsSizeEncoded to oldConstraints.size - 1) {
      add(oldConstraints(n))
      if (n == csp.constraintsSize - 1) {
        csp.constraintsSize = csp.constraints.size
        csp.boolsSize = csp.bools.size
      }
    }
    variablesSizeEncoded = csp.variables.size
    boolsSizeEncoded = csp.bools.size
    constraintsSizeEncoded = csp.constraints.size
  }

  /** Returns the value of `x` from the satisfiable assignment found by the SAT solver. */
  def decode(x: IntVar): Int

  /** Returns the satisfiable assignment of CSP from the satisfiable assignment found by the SAT solver. */
  def decode: Assignment = {
    var varAssign: Map[IntVar, Int] = Map.empty
    var boolAssign: Map[BooleanVar, Boolean] = Map.empty
    for (x <- csp.variables)
      varAssign += x -> decode(x)
    for (p <- csp.bools)
      boolAssign += p -> satSolver.model(boolCodeMap(p))
    // varAssign = varAssign.filter(! _._1.aux)
    // boolAssign = boolAssign.filter(! _._1.aux)
    new Assignment(varAssign, boolAssign)
  }

}
